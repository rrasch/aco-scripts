--- /home/rasan/hocr-pdf	2025-10-30 22:01:23.725763892 -0400
+++ /home/rasan/Downloads/hocr-tools-1.3.0/hocr-pdf	2025-11-13 00:20:22.848011280 -0500
@@ -19,11 +19,14 @@
 
 import argparse
 import base64
+import functools
 import glob
 import io
+import logging
 import os.path
 import re
 import sys
+import unicodedata
 import zlib
 
 from bidi.algorithm import get_display
@@ -48,48 +51,58 @@
         sys.stdout.write(data)
 
 
-def export_pdf(playground, default_dpi, savefile=False):
+def export_pdf(playground, default_dpi, reverse, savefile=False):
     """Create a searchable PDF from a pile of HOCR + JPEG"""
     images = sorted(glob.glob(os.path.join(playground, '*.jpg')))
     if len(images) == 0:
         print(f"WARNING: No JPG images found in the folder {playground}"
               "\nScript cannot proceed without them and will terminate now.\n")
         sys.exit(0)
-    load_invisible_font()
+    load_cour_font()
     pdf = Canvas(savefile if savefile else StdoutWrapper(), pageCompression=1)
     pdf.setCreator('hocr-tools')
     pdf.setTitle(os.path.basename(playground))
-    dpi = default_dpi
     for image in images:
         im = Image.open(image)
         w, h = im.size
-        try:
-            dpi = im.info['dpi'][0]
-        except KeyError:
-            pass
+        logging.debug("image dimensions (%s): %s", image, im.size)
+        dpi = im.info['dpi'][0]
         width = w * 72 / dpi
         height = h * 72 / dpi
         pdf.setPageSize((width, height))
         pdf.drawImage(image, 0, 0, width=width, height=height)
-        add_text_layer(pdf, image, height, dpi)
+        add_text_layer(pdf, image, height, dpi, w, reverse)
         pdf.showPage()
     pdf.save()
 
 
-def add_text_layer(pdf, image, height, dpi):
+def add_text_layer(pdf, image, height, dpi, img_width, reverse):
     """Draw an invisible text layer for OCR data"""
-    p1 = re.compile(r'bbox((\s+\d+){4})')
+    p1 = re.compile(r'bbox((\s+-?\d+){4})')
     p2 = re.compile(r'baseline((\s+[\d\.\-]+){2})')
+
     hocrfile = os.path.splitext(image)[0] + ".hocr"
-    hocr = etree.parse(hocrfile, html.XHTMLParser())
-    for line in hocr.xpath('//*[@class="ocr_line"]'):
+    hocr = html.parse(hocrfile)
+
+    scale_to_pts = calc_scale_pts(hocr, dpi, img_width)
+
+    lang = get_language(hocr)
+    logging.debug("language %s: %s", hocrfile, lang)
+
+    if reverse == "lang":
+        if lang:
+            reverse = "yes" if is_rtl_lang(lang) else "no"
+        else:
+            raise ValueError(f"Missing or empty language in file {hocrfile}")
+
+    for line in hocr.xpath('//*[@class="ocr_line" or @class="ocrx_line"]'):
         linebox = p1.search(line.attrib['title']).group(1).split()
         try:
             baseline = p2.search(line.attrib['title']).group(1).split()
         except AttributeError:
             baseline = [0, 0]
-        linebox = [float(i) for i in linebox]
-        baseline = [float(i) for i in baseline]
+        linebox = [max(float(i), 0.0) for i in linebox]
+        baseline = [max(float(i), 0.0) for i in baseline]
         xpath_elements = './/*[@class="ocrx_word"]'
         if (not (line.xpath('boolean(' + xpath_elements + ')'))):
             # if there are no words elements present,
@@ -99,20 +112,25 @@
             rawtext = word.text_content().strip()
             if rawtext == '':
                 continue
-            font_width = pdf.stringWidth(rawtext, 'invisible', 8)
+
+            rawtext = reverse_handler[reverse](rawtext)
+
+            box = p1.search(word.attrib['title']).group(1).split()
+            box = [max(float(i), 0.0) for i in box]
+            font_name = 'CourierNew'
+            font_scale = 2.0
+            font_size = int((box[3] - box[1]) * scale_to_pts * font_scale)
+            font_width = pdf.stringWidth(rawtext, font_name, font_size)
             if font_width <= 0:
                 continue
-            box = p1.search(word.attrib['title']).group(1).split()
-            box = [float(i) for i in box]
             b = polyval(baseline,
                         (box[0] + box[2]) / 2 - linebox[0]) + linebox[3]
             text = pdf.beginText()
             text.setTextRenderMode(3)  # double invisible
-            text.setFont('invisible', 8)
-            text.setTextOrigin(box[0] * 72 / dpi, height - b * 72 / dpi)
-            box_width = (box[2] - box[0]) * 72 / dpi
+            text.setFont(font_name, font_size)
+            text.setTextOrigin(box[0] * scale_to_pts, height - b * scale_to_pts)
+            box_width = (box[2] - box[0]) * scale_to_pts
             text.setHorizScale(100.0 * box_width / font_width)
-            rawtext = get_display(rawtext)
             text.textLine(rawtext)
             pdf.drawText(text)
 
@@ -153,6 +171,185 @@
     pdfmetrics.registerFont(TTFont('invisible', ttf))
 
 
+def trace(func):
+    """Log function call with repr-style arguments and return value."""
+    @functools.wraps(func)
+    def wrapper(*args, **kwargs):
+        args_repr = [repr(a) for a in args]
+        kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]
+        signature = ", ".join(args_repr + kwargs_repr)
+
+        logging.debug("Calling %s(%s)", func.__name__, signature)
+        result = func(*args, **kwargs)
+        logging.debug("%s returned %r", func.__name__, result)
+        return result
+    return wrapper
+
+
+def is_ubuntu():
+    try:
+        with open("/etc/os-release") as f:
+            return any("ID=ubuntu" in line for line in f)
+    except FileNotFoundError:
+        return False
+
+
+def load_cour_font():
+    if is_ubuntu():
+        ttf_file = "/usr/share/fonts/truetype/msttcorefonts/cour.ttf"
+    else:
+        ttf_file = "/usr/share/fonts/msttcore/cour.ttf"
+    pdfmetrics.registerFont(TTFont("CourierNew", ttf_file))
+
+
+@trace
+def get_page_bbox(tree):
+    """Extract the page bounding box, width, and height."""
+    page_divs = tree.xpath('//div[@class="ocr_page"]')
+    if not page_divs:
+        return None
+
+    title_attr = page_divs[0].get("title", "")
+    if "bbox" not in title_attr:
+        return None
+
+    bbox_str = title_attr.split("bbox")[1].split(";")[0].strip()
+    x1, y1, x2, y2 = map(int, bbox_str.split())
+
+    return {
+        "bbox": (x1, y1, x2, y2),
+        "width": x2 - x1,
+        "height": y2 - y1,
+    }
+
+
+@trace
+def get_language(tree):
+    """
+    Returns the value of the <meta name="language" content="..."> tag
+    in the given HTML tree, or None if not found.
+    """
+    langs = tree.xpath('//meta[@name="language"]/@content')
+    if not langs:
+        return None
+    return langs[0].strip().lower()
+
+
+@trace
+def calc_scale_pts(hocr, dpi, img_width):
+    """
+    Calculate the scale factor to convert HOCR coordinates to PDF points.
+
+    PDFs use points as their measurement unit, where 72 points equal one inch.
+    This function determines how much HOCR coordinates must be scaled to match
+    the corresponding PDF dimensions based on the page bounding box width,
+    image width, and DPI.
+
+    Args:
+        hocr (lxml.etree._Element): The root HOCR element representing the page
+            layout and bounding box information.
+        dpi (int or float): The image resolution in dots per inch.
+        img_width (int or float): The actual width of the image in pixels.
+
+    Returns:
+        float: The scale factor used to convert HOCR coordinates to PDF points.
+    """
+    bbox = get_page_bbox(hocr)
+    scale = img_width / bbox["width"] if bbox else 1.0
+    logging.debug("scale hocr: %s", scale)
+    scale *= 72 / dpi
+    return scale
+
+
+# Split into directional/script runs:
+#  - Arabic blocks (includes Arabic-Indic digits)
+#  - Latin A–Z (covers English/French/Spanish letters)
+#  - ASCII digits 0–9
+#  - Any other single non-space symbol/punct
+_RUN_RE = re.compile(
+    r'([\u0600-\u06FF\u0750-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+)'
+    r'|([A-Za-z]+)'
+    r'|([0-9]+)'
+    r'|(\S)'
+)
+
+
+@trace
+def _is_arabic_char(ch: str) -> bool:
+    # Conservative: only reverse when unicode name contains "ARABIC"
+    # (This leaves Latin and punctuation alone.)
+    return "ARABIC" in unicodedata.name(ch, "")
+
+
+@trace
+def fix_word(text: str) -> str:
+    """
+    Convert Google Vision's visual-order RTL runs to logical order,
+    preserving Latin letters, ASCII digits, and punctuation as-is.
+    Use this on each ocrx_word's text BEFORE sending to PDF.
+    """
+    parts = []
+    for ar, lat, num, other in _RUN_RE.findall(text or ""):
+        if ar and all(_is_arabic_char(c) for c in ar):
+            # Reverse ONLY Arabic runs: visual → logical
+            logging.debug("Arabic found: %s", ar)
+            parts.append(ar[::-1])
+        elif lat:
+            parts.append(lat)   # leave Latin (French/Spanish/English) as-is
+        elif num:
+            parts.append(num)   # leave ASCII digits as-is
+        else:
+            parts.append(other) # punctuation/symbols
+    fixed_text = "".join(parts)
+    return fixed_text
+
+
+# ---------------------------------------------------------------------
+# RTL language codes (ISO 639-1, 639-2, 639-3)
+# ---------------------------------------------------------------------
+RTL_LANGS = {
+    # Arabic family
+    "ar", "ara",
+    "fa", "fas", "per",    # Persian (Farsi)
+    "ur", "urd",           # Urdu
+    "ps", "pus",           # Pashto
+    "sd", "snd",           # Sindhi
+    "ug", "uig",           # Uyghur
+
+    # Hebrew / Yiddish
+    "he", "heb",
+    "iw",                  # legacy Hebrew
+    "yi", "yid",           # Yiddish
+
+    # Kurdish (mixed, but Sorani is RTL)
+    "ku", "kur",
+    "ckb",
+}
+
+
+@trace
+def is_rtl_lang(lang):
+    """
+    Return True if the given language code is a right-to-left language.
+
+    Raises ValueError if `lang` is empty, None, or contains only whitespace.
+    Supports ISO 639-1 (2-letter) and ISO 639-2/3 (3-letter) codes.
+    Works in Python 3.6+.
+    """
+    if not lang or not lang.strip():
+        raise ValueError("Language code must be a non-empty string")
+
+    code = lang.strip().lower()
+    return code in RTL_LANGS
+
+
+reverse_handler = {
+    "auto": lambda s: fix_word(s),
+    "yes":  lambda s: s[::-1],
+    "no":   lambda s: s,
+}
+
+
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(
         description="Create a searchable PDF from a pile of hOCR and JPEG")
@@ -166,7 +363,30 @@
         "--savefile",
         help="Save to this file instead of outputting to stdout"
     )
+    parser.add_argument(
+        "--reverse",
+        choices=["auto", "lang", "yes", "no"],
+        default="auto",
+        help=(
+            "Control when words are reversed before adding them to the PDF."
+            " 'auto' tries to detect RTL text automatically. 'lang' reverses"
+            " words only when the HOCR element's 'lang' attribute indicates an"
+            " RTL language (Arabic or Hebrew). 'yes' always reverses and 'no'"
+            " never reverses. (default: %(default)s)"
+        ),
+    )
+    parser.add_argument(
+        "-d", "--debug", action="store_true", help="Enable debugging"
+    )
     args = parser.parse_args()
+
+    script_name = os.path.basename(__file__)
+    level = logging.DEBUG if args.debug else logging.WARNING
+    logging.basicConfig(
+        format=f"%(asctime)s %(levelname)s {script_name}: %(message)s",
+        level=level,
+    )
+
     if not os.path.isdir(args.imgdir):
         sys.exit(f"ERROR: Given path '{args.imgdir}' is not a directory")
-    export_pdf(args.imgdir, 300, args.savefile)
+    export_pdf(args.imgdir, 300, args.reverse, args.savefile)
